<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Precision Gesture Engine</title>
    <style>
        /* --- UI STYLING --- */
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; color: #fff; }
        
        #sidebar {
            width: 280px; background: #0a0a0a; border-right: 1px solid #222;
            display: flex; flex-direction: column; z-index: 20; flex-shrink: 0;
        }
        .header { padding: 20px; border-bottom: 1px solid #222; background: #111; }
        .header h2 { margin: 0; color: #00ffa3; font-size: 1rem; text-transform: uppercase; letter-spacing: 2px; }
        
        #list { flex-grow: 1; overflow-y: auto; padding: 10px; }
        
        .item { 
            display: flex; align-items: center; padding: 10px; 
            margin-bottom: 5px; border-radius: 8px; cursor: pointer; 
            border: 1px solid transparent; transition: 0.2s; background: #141414;
        }
        .item.active { background: rgba(0, 255, 163, 0.1); border-color: #00ffa3; box-shadow: 0 0 10px rgba(0,255,163,0.1); }
        .icon { font-size: 1.5rem; width: 40px; text-align: center; }
        .name { font-size: 0.9rem; font-weight: bold; color: #ddd; }
        
        #main { flex-grow: 1; position: relative; background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%); }
        
        #debug-overlay {
            position: absolute; top: 20px; left: 20px;
            color: rgba(255,255,255,0.5); font-family: monospace; font-size: 0.8rem;
            pointer-events: none;
        }

        #cam-box {
            position: absolute; bottom: 20px; right: 20px;
            width: 160px; height: 120px;
            border: 2px solid #333; border-radius: 10px;
            overflow: hidden; opacity: 0.8; background: #000;
        }
        #webcam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        @media (max-width: 768px) {
            body { flex-direction: column; }
            #sidebar { width: 100%; height: 30vh; border-right: none; border-top: 1px solid #333; order: 2; }
            #main { height: 70vh; order: 1; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

    <div id="sidebar">
        <div class="header"><h2>Precision Mode</h2></div>
        <div id="list"></div>
    </div>

    <div id="main">
        <div id="debug-overlay">Waiting for hand...</div>
        <div id="cam-box"><video id="webcam" playsinline muted autoplay></video></div>
    </div>

<script>
    // --- 1. SYMBOL DEFINITIONS ---
    const SYMBOLS = [
        { id: 'bigbang', icon: 'â˜ï¸', name: 'Big Bang', type: 'one-up-palm' },
        { id: 'cloud',   icon: 'ðŸ‘†', name: 'Cloud', type: 'one-up-back' },
        { id: 'rain',    icon: 'ðŸ‘‡', name: 'Rain', type: 'one-down' },
        { id: 'sun',     icon: 'ðŸ‘ˆ', name: 'Sun', type: 'one-left' },
        { id: 'saturn',  icon: 'ðŸ‘‰', name: 'Saturn', type: 'one-right' },
        
        { id: 'heart',   icon: 'âœŠ', name: 'Heart', type: 'fist-up' },
        { id: 'cube',    icon: 'ðŸ‘Š', name: 'Cube', type: 'fist-punch' },
        { id: 'butterfly', icon: 'ðŸ¤›', name: 'Butterfly', type: 'fist-side' },
        
        { id: 'milkyway', icon: 'âœ‹', name: 'Milky Way', type: 'open-palm' },
        { id: 'pizza',    icon: 'ðŸ–ï¸', name: 'Pizza', type: 'open-spread' },
        { id: 'birds',    icon: 'ðŸ¤š', name: 'Birds', type: 'open-back' },
        { id: 'river',    icon: 'ðŸ«±', name: 'River', type: 'open-side' },
        { id: 'dna',      icon: 'ðŸ‘‹', name: 'DNA', type: 'wave' },
        
        { id: 'cake',    icon: 'âœŒï¸', name: 'Cake', type: 'victory' },
        { id: 'blackhole', icon: 'ðŸ‘Œ', name: 'Black Hole', type: 'pinch' },
        { id: 'sphere',  icon: 'ðŸ‘', name: 'Sphere', type: 'thumb-up' },
        { id: 'donut',   icon: 'ðŸ‘Ž', name: 'Donut', type: 'thumb-down' },
        { id: 'burger',  icon: 'ðŸ––', name: 'Burger', type: 'vulcan' },
        { id: 'crown',   icon: 'ðŸ¤™', name: 'Crown', type: 'shaka' },
        { id: 'cat',     icon: 'ðŸ¤Ÿ', name: 'Cat', type: 'rock' },
        { id: 'color',   icon: 'ðŸ¤˜', name: 'Color Shift', type: 'metal' }
    ];

    // --- 2. BUILD UI ---
    const list = document.getElementById('list');
    SYMBOLS.forEach(s => {
        const el = document.createElement('div');
        el.className = 'item';
        el.id = `item-${s.id}`;
        el.innerHTML = `<div class="icon">${s.icon}</div><div class="name">${s.name}</div>`;
        list.appendChild(el);
    });

    // --- 3. THREE.JS ENGINE ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 40;
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('main').appendChild(renderer.domElement);

    const PARTICLE_COUNT = 15000;
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(PARTICLE_COUNT*3);
    const target = new Float32Array(PARTICLE_COUNT*3);
    const col = new Float32Array(PARTICLE_COUNT*3);
    const baseCol = new Float32Array(PARTICLE_COUNT*3);

    for(let i=0; i<PARTICLE_COUNT*3; i++) {
        pos[i] = (Math.random()-0.5)*100;
        target[i] = pos[i];
        col[i]=1; baseCol[i]=1;
    }
    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
    const particles = new THREE.Points(geo, new THREE.PointsMaterial({size: 0.15, vertexColors: true, transparent: true, opacity: 0.8}));
    scene.add(particles);

    function setShape(id) {
        let r=0, g=1, b=0.8; // Default Cyan
        
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const idx = i*3;
            const u = Math.random(); const v = Math.random();
            let x=0, y=0, z=0;
            const PI = Math.PI;

            // --- SHAPE MATH ---
            if (id === 'bigbang') { x=(u-0.5)*60; y=(v-0.5)*60; z=(Math.random()-0.5)*60; r=1; g=0.9; b=0.5; }
            else if (id === 'cloud') { x=(u-0.5)*40; y=(v-0.5)*15; z=(Math.random()-0.5)*15; r=1; g=1; b=1; }
            else if (id === 'rain') { x=(u-0.5)*30; y=20-v*40; z=(Math.random()-0.5)*30; r=0; g=0.5; b=1; }
            else if (id === 'sun') { const rad=12; x=rad*Math.cos(u*2*PI)*Math.sin(v*PI); y=rad*Math.sin(u*2*PI)*Math.sin(v*PI); z=rad*Math.cos(v*PI); x+=(Math.random()-0.5)*5; r=1; g=0.5; b=0; }
            else if (id === 'saturn') { 
                if(i<PARTICLE_COUNT*0.7) { x=8*Math.cos(u*2*PI)*Math.sin(v*PI); z=8*Math.sin(u*2*PI)*Math.sin(v*PI); y=8*Math.cos(v*PI); }
                else { const ang=u*2*PI; const rad=12+v*6; x=rad*Math.cos(ang); z=rad*Math.sin(ang); y=0; }
                const t=0.4; const _y=y*Math.cos(t)-z*Math.sin(t); const _z=y*Math.sin(t)+z*Math.cos(t); y=_y; z=_z; r=1; g=0.8; b=0.4;
            }
            else if (id === 'heart') { const t=u*2*PI; x=16*Math.pow(Math.sin(t),3); y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t); z=(v-0.5)*5; r=1; g=0; b=0.2; }
            else if (id === 'cube') { const s=18; x=(u-0.5)*s; y=(v-0.5)*s; z=(Math.random()-0.5)*s; r=0; g=1; b=0; }
            else if (id === 'butterfly') { const t=u*2*PI; const R = Math.exp(Math.cos(t)) - 2*Math.cos(4*t) - Math.pow(Math.sin(t/12),5); x=R*Math.cos(t)*8; y=R*Math.sin(t)*8; z=(v-0.5)*5; r=1; g=0; b=1; }
            else if (id === 'milkyway') { const ang=u*25+i*0.05; const rad=u*25; x=rad*Math.cos(ang); z=rad*Math.sin(ang); y=(v-0.5)*5; r=0.5; g=0; b=1; }
            else if (id === 'pizza') { const ang=v*2*PI; const rad=u*15; x=rad*Math.cos(ang); z=rad*Math.sin(ang); y=0; if(Math.random()>0.9) y=1; r=1; g=0.6; b=0; }
            else if (id === 'birds') { x=(u-0.5)*40; z=(v-0.5)*20; y=Math.sin(x*0.3+i)*2 + Math.abs(Math.sin(i*0.1))*3; r=1; g=1; b=1; }
            else if (id === 'river') { x=(u-0.5)*50; z=(v-0.5)*20; y=5*Math.sin(x*0.2+i*0.001); r=0; g=0.5; b=1; }
            else if (id === 'dna') { const h=(u-0.5)*40; const a=h*0.5; const off=i%2==0?0:PI; x=8*Math.cos(a+off); z=8*Math.sin(a+off); y=h; r=1; g=0; b=0.5; }
            else if (id === 'cake') { const l=i%3; const rad=l==0?10:l==1?7:4; const h=l==0?-5:l==1?0:5; x=rad*Math.cos(u*2*PI); z=rad*Math.sin(u*2*PI); y=h+(v-0.5)*3; r=1; g=0.4; b=0.6; }
            else if (id === 'blackhole') { const rad=6+u*10; const ang=v*2*PI+rad; x=rad*Math.cos(ang); z=rad*Math.sin(ang); y=(10/rad)*-8; r=0.2; g=0; b=0.4; }
            else if (id === 'sphere') { x=15*Math.cos(u*2*PI)*Math.sin(v*PI); y=15*Math.sin(u*2*PI)*Math.sin(v*PI); z=15*Math.cos(v*PI); r=0; g=0.8; b=1; }
            else if (id === 'donut') { const R=12; const _r=4; x=(R+_r*Math.cos(v*2*PI))*Math.cos(u*2*PI); y=(R+_r*Math.cos(v*2*PI))*Math.sin(u*2*PI); z=_r*Math.sin(v*2*PI); r=1; g=0.5; b=0; }
            else if (id === 'burger') { const l=i%3; const rad=9; const h=l==0?-4:l==1?0:4; x=rad*Math.cos(u*2*PI); z=rad*Math.sin(u*2*PI); y=h+(v-0.5)*3; if(l==1){x*=0.9; z*=0.9;} r=1; g=0.6; b=0.2; }
            else if (id === 'crown') { const ang=u*2*PI; const rad=10; x=rad*Math.cos(ang); z=rad*Math.sin(ang); y=5*Math.abs(Math.sin(ang*2.5))-5; r=1; g=0.8; b=0; }
            else if (id === 'cat') { x=8*Math.cos(u*2*PI)*Math.sin(v*PI); y=8*Math.sin(u*2*PI)*Math.sin(v*PI); z=8*Math.cos(v*PI); if(i>PARTICLE_COUNT*0.8){ x=4+u*3; y=6+v*4; z=0; } if(i>PARTICLE_COUNT*0.9){ x=-4-u*3; y=6+v*4; z=0; } r=0.8; g=0.4; b=1; }
            else if (id === 'color') { x=(Math.random()-0.5)*50; y=(Math.random()-0.5)*50; z=(Math.random()-0.5)*50; r=Math.random(); g=Math.random(); b=Math.random(); }

            target[idx]=x; target[idx+1]=y; target[idx+2]=z;
            baseCol[idx]=r; baseCol[idx+1]=g; baseCol[idx+2]=b;
        }
    }

    let currentSymbol = '';
    function activate(id) {
        if(currentSymbol === id) return;
        currentSymbol = id;
        document.querySelectorAll('.item').forEach(e => e.classList.remove('active'));
        const el = document.getElementById(`item-${id}`);
        if(el) {
            el.classList.add('active');
            el.scrollIntoView({block:'center', behavior:'smooth'});
        }
        setShape(id);
    }

    // --- 4. ADVANCED DETECTION ENGINE ---
    function detectSymbol(lm) {
        // A. FINGER STATES (Extended if Tip is further from Wrist than Pip)
        // We use distance to wrist (0)
        const d = (i) => Math.hypot(lm[i].x-lm[0].x, lm[i].y-lm[0].y);
        // Compare Tip(8) distance vs Pip(6) distance
        const isExt = (tip, pip) => d(tip) > d(pip) * 1.1; // 10% buffer
        
        const i = isExt(8,6);
        const m = isExt(12,10);
        const r = isExt(16,14);
        const p = isExt(20,18);
        const t = d(4) > d(3) * 1.1; // Thumb simple check

        const count = [t,i,m,r,p].filter(Boolean).length;

        // B. DIRECTION VECTOR (Wrist -> Middle Finger MCP)
        // This gives 360 degree direction of hand
        const dx = lm[9].x - lm[0].x;
        const dy = lm[9].y - lm[0].y;
        const angle = Math.atan2(dy, dx) * (180/Math.PI); // -180 to 180
        
        let dir = 'down'; // 90ish
        if (angle > -45 && angle < 45) dir = 'left'; // Camera is mirrored
        else if (angle > 45 && angle < 135) dir = 'down';
        else if (angle < -45 && angle > -135) dir = 'up';
        else dir = 'right';

        // C. PALM vs BACK (Handedness Heuristic)
        // For a Right hand (on screen Left), Thumb is Left of Index = Palm
        // We will assume standard "Selfie" mirroring
        const isPalm = lm[4].x < lm[17].x; // Thumb vs Pinky X-check

        // D. PINCH CHECK
        const pinchDist = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y);
        const isPinch = pinchDist < 0.05;

        // E. Z-DEPTH (Punch Check)
        // If Knuckles(9) Z is significantly less than Wrist(0) Z
        // Note: MP Z is relative to wrist, so check absolute values
        const isPunch = lm[9].z < -0.15; // Closer to camera

        // --- DEBUG INFO ---
        document.getElementById('debug-overlay').innerHTML = 
            `Fingers: ${count}<br>Dir: ${dir}<br>Palm: ${isPalm}<br>Pinch: ${isPinch.toFixed(2)}`;

        // --- MAPPING ---
        
        // 1. PINCH PRIORITY
        if (isPinch && m && r && p) return 'blackhole'; // ðŸ‘Œ

        // 2. FISTS (0 Fingers)
        if (count === 0 || (count === 1 && t)) {
            if (isPunch) return 'cube'; // ðŸ‘Š Punch forward
            if (dir === 'up') return 'heart'; // âœŠ
            if (dir === 'left' || dir === 'right') return 'butterfly'; // ðŸ¤›
        }

        // 3. THUMBS ONLY
        if (t && !i && !m && !r && !p) {
            return dir === 'up' ? 'sphere' : 'donut'; // ðŸ‘ ðŸ‘Ž (Approx based on angle)
        }

        // 4. ONE FINGER (INDEX)
        if (i && !m && !r && !p) {
            if (dir === 'down') return 'rain'; // ðŸ‘‡
            if (dir === 'left') return 'sun'; // ðŸ‘ˆ
            if (dir === 'right') return 'saturn'; // ðŸ‘‰
            if (dir === 'up') return isPalm ? 'bigbang' : 'cloud'; // â˜ï¸ vs ðŸ‘†
        }

        // 5. TWO FINGERS
        if (i && m && !r && !p) return 'cake'; // âœŒï¸
        if (t && p && !i && !m && !r) return 'crown'; // ðŸ¤™
        if (i && p && !m && !r) return 'color'; // ðŸ¤˜

        // 6. OPEN HAND (5 Fingers)
        if (count >= 4) {
            // Check Spread (Index vs Pinky distance)
            const spread = Math.hypot(lm[8].x-lm[20].x, lm[8].y-lm[20].y);
            
            if (dir === 'left' || dir === 'right') {
                if (Math.abs(angle) < 20 || Math.abs(angle) > 160) return 'river'; // ðŸ«± Horizontal
                return 'dna'; // ðŸ‘‹ Waving (tilted)
            }
            if (spread > 0.3) return 'pizza'; // ðŸ–ï¸ Wide
            if (!isPalm) return 'birds'; // ðŸ¤š Back
            
            // Vulcan Logic (Gap between Middle and Ring)
            // Dist(12,16) vs Dist(8,12)
            const midRing = Math.hypot(lm[12].x-lm[16].x, lm[12].y-lm[16].y);
            const indMid = Math.hypot(lm[8].x-lm[12].x, lm[8].y-lm[12].y);
            if (midRing > indMid * 1.5) return 'burger'; // ðŸ––

            return 'milkyway'; // âœ‹ Standard
        }
        
        // 7. THREE FINGERS
        if (i && m && p && !r) return 'cat'; // ðŸ¤Ÿ

        return currentSymbol;
    }

    function onResults(results) {
        if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const id = detectSymbol(results.multiHandLandmarks[0]);
            activate(id);
        }
    }

    // --- 5. CAMERA START ---
    const vid = document.getElementById('webcam');
    const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.6}); // Complexity 1 for better accuracy
    hands.onResults(onResults);
    
    const cam = new Camera(vid, {
        onFrame: async () => await hands.send({image: vid}),
        width: 640, height: 480, facingMode: 'user'
    });
    cam.start();
    activate('bigbang'); // Init

    // --- 6. ANIM LOOP ---
    function animate() {
        requestAnimationFrame(animate);
        const p = particles.geometry.attributes.position.array;
        const c = particles.geometry.attributes.color.array;
        for(let i=0; i<PARTICLE_COUNT*3; i++){
            p[i] += (target[i]-p[i]) * 0.08;
            c[i] += (baseCol[i]-c[i]) * 0.05;
        }
        particles.geometry.attributes.position.needsUpdate = true;
        particles.geometry.attributes.color.needsUpdate = true;
        particles.rotation.y += 0.002;
        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>

