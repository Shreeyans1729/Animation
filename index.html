<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Robust Gesture Engine</title>
    <style>
        /* --- DARK THEME UI --- */
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; color: #fff; }
        
        #sidebar {
            width: 300px; background: #0f0f0f; border-right: 1px solid #333;
            display: flex; flex-direction: column; z-index: 20; flex-shrink: 0;
            box-shadow: 5px 0 20px rgba(0,0,0,0.5);
        }
        .header { padding: 15px; background: #161616; border-bottom: 1px solid #333; }
        .header h2 { margin: 0; color: #00ff88; font-size: 1.1rem; text-transform: uppercase; letter-spacing: 1px; }
        .header p { margin: 5px 0 0; font-size: 0.8rem; color: #888; }
        
        #status-bar { padding: 10px; background: #222; font-size: 0.8rem; color: #00ff88; font-family: monospace; border-bottom: 1px solid #333; }
        
        #list { flex-grow: 1; overflow-y: auto; padding: 10px; scroll-behavior: smooth; }
        
        .item { 
            display: flex; align-items: center; padding: 8px 12px; margin-bottom: 6px; 
            border-radius: 6px; cursor: pointer; transition: 0.2s; background: #1a1a1a; border-left: 3px solid transparent;
        }
        .item:hover { background: #252525; }
        .item.active { background: rgba(0, 255, 136, 0.15); border-left-color: #00ff88; }
        .icon { font-size: 1.5rem; width: 40px; text-align: center; margin-right: 10px; }
        .name { font-weight: 600; font-size: 0.95rem; }
        
        /* --- MAIN VIEW --- */
        #main { flex-grow: 1; position: relative; background: radial-gradient(circle at center, #111 0%, #000 100%); }
        
        /* DEBUG CAMERA OVERLAY */
        #cam-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 240px; height: 180px;
            border: 2px solid #444; border-radius: 12px;
            overflow: hidden; z-index: 10; background: #000;
        }
        #webcam { position: absolute; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #output_canvas { position: absolute; width: 100%; height: 100%; transform: scaleX(-1); }

        /* TOAST NOTIFICATION */
        #toast {
            position: absolute; top: 40px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 255, 136, 0.9); color: #000;
            padding: 10px 30px; border-radius: 30px; font-weight: bold; font-size: 1.2rem;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
            opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 30;
        }

        @media (max-width: 768px) {
            body { flex-direction: column; }
            #sidebar { width: 100%; height: 40vh; border-right: none; border-top: 1px solid #333; order: 2; }
            #main { height: 60vh; order: 1; }
            #cam-container { width: 120px; height: 90px; top: 10px; right: 10px; bottom: auto; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>
<body>

    <div id="sidebar">
        <div class="header">
            <h2>Gestures 2.0</h2>
            <p>Stabilized & Visualized</p>
        </div>
        <div id="status-bar">Status: Loading AI...</div>
        <div id="list"></div>
    </div>

    <div id="main">
        <div id="toast">Ready</div>
        <div id="cam-container">
            <video id="webcam" playsinline muted autoplay></video>
            <canvas id="output_canvas"></canvas>
        </div>
    </div>

<script>
    // --- 1. CONFIG ---
    const CONFIG = {
        mobile: /Mobi|Android/i.test(navigator.userAgent),
        particles: /Mobi|Android/i.test(navigator.userAgent) ? 12000 : 25000,
        stabilizationFrames: 5 // Must hold gesture for 5 frames to switch
    };

    const SYMBOLS = [
        { id: 'bigbang', icon: 'â˜ï¸', name: 'Big Bang', hint: 'Index Up (Palm)' },
        { id: 'cloud',   icon: 'ðŸ‘†', name: 'Cloud', hint: 'Index Up (Back)' },
        { id: 'rain',    icon: 'ðŸ‘‡', name: 'Rain', hint: 'Index Down' },
        { id: 'sun',     icon: 'ðŸ‘ˆ', name: 'Sun', hint: 'Index Left' },
        { id: 'saturn',  icon: 'ðŸ‘‰', name: 'Saturn', hint: 'Index Right' },
        { id: 'heart',   icon: 'âœŠ', name: 'Heart', hint: 'Fist Up' },
        { id: 'cube',    icon: 'ðŸ‘Š', name: 'Cube', hint: 'Fist Forward' },
        { id: 'butterfly', icon: 'ðŸ¤›', name: 'Butterfly', hint: 'Fist Sideways' },
        { id: 'milkyway', icon: 'âœ‹', name: 'Milky Way', hint: 'Palm Open' },
        { id: 'pizza',    icon: 'ðŸ–ï¸', name: 'Pizza', hint: 'Fingers Spread' },
        { id: 'birds',    icon: 'ðŸ¤š', name: 'Birds', hint: 'Back of Hand' },
        { id: 'river',    icon: 'ðŸ«±', name: 'River', hint: 'Side Hand' },
        { id: 'dna',      icon: 'ðŸ‘‹', name: 'DNA', hint: 'Wave' },
        { id: 'cake',    icon: 'âœŒï¸', name: 'Cake', hint: 'Victory' },
        { id: 'blackhole', icon: 'ðŸ‘Œ', name: 'Black Hole', hint: 'OK Sign' },
        { id: 'sphere',  icon: 'ðŸ‘', name: 'Sphere', hint: 'Thumb Up' },
        { id: 'donut',   icon: 'ðŸ‘Ž', name: 'Donut', hint: 'Thumb Down' },
        { id: 'burger',  icon: 'ðŸ––', name: 'Burger', hint: 'Vulcan' },
        { id: 'crown',   icon: 'ðŸ¤™', name: 'Crown', hint: 'Shaka' },
        { id: 'cat',     icon: 'ðŸ¤Ÿ', name: 'Cat', hint: 'Rock On' },
        { id: 'color',   icon: 'ðŸ¤˜', name: 'Color Shift', hint: 'Horns' }
    ];

    // --- 2. BUILD SIDEBAR ---
    const list = document.getElementById('list');
    SYMBOLS.forEach(s => {
        const div = document.createElement('div');
        div.className = 'item';
        div.id = `item-${s.id}`;
        div.innerHTML = `<div class="icon">${s.icon}</div><div><div class="name">${s.name}</div><div style="font-size:0.7em; color:#888;">${s.hint}</div></div>`;
        div.onclick = () => activateSymbol(s.id);
        list.appendChild(div);
    });

    // --- 3. THREE.JS ENGINE (Particles) ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = CONFIG.mobile ? 55 : 40;
    
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.getElementById('main').appendChild(renderer.domElement);

    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(CONFIG.particles * 3);
    const target = new Float32Array(CONFIG.particles * 3);
    const col = new Float32Array(CONFIG.particles * 3);
    const baseCol = new Float32Array(CONFIG.particles * 3);

    for(let i=0; i<CONFIG.particles; i++){
        pos[i*3] = (Math.random()-0.5)*100;
        target[i*3]=pos[i*3];
        col[i*3]=1; baseCol[i*3]=1;
    }
    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
    const particles = new THREE.Points(geo, new THREE.PointsMaterial({size: 0.2, vertexColors: true, transparent: true, opacity: 0.8}));
    scene.add(particles);

    // --- 4. SHAPE GENERATOR ---
    function setShape(id) {
        let r=0, g=1, b=0.8; 
        
        for(let i=0; i<CONFIG.particles; i++) {
            const idx = i*3;
            const u = Math.random(); const v = Math.random();
            const PI = Math.PI;
            let x=0, y=0, z=0;

            if (id === 'bigbang') { x=(u-0.5)*60; y=(v-0.5)*60; z=(Math.random()-0.5)*60; r=1; g=0.9; b=0.5; }
            else if (id === 'cloud') { x=(u-0.5)*40; y=(v-0.5)*15; z=(Math.random()-0.5)*15; r=1; g=1; b=1; }
            else if (id === 'rain') { x=(u-0.5)*30; y=20-v*40; z=(Math.random()-0.5)*30; r=0; g=0.5; b=1; }
            else if (id === 'sun') { const rad=12; x=rad*Math.cos(u*2*PI)*Math.sin(v*PI); y=rad*Math.sin(u*2*PI)*Math.sin(v*PI); z=rad*Math.cos(v*PI); r=1; g=0.6; b=0; }
            else if (id === 'saturn') { 
                if(i<CONFIG.particles*0.7) { x=8*Math.cos(u*2*PI)*Math.sin(v*PI); z=8*Math.sin(u*2*PI)*Math.sin(v*PI); y=8*Math.cos(v*PI); }
                else { const ang=u*2*PI; const rad=12+v*6; x=rad*Math.cos(ang); z=rad*Math.sin(ang); y=0; }
                const t=0.4; const _y=y*Math.cos(t)-z*Math.sin(t); const _z=y*Math.sin(t)+z*Math.cos(t); y=_y; z=_z; r=1; g=0.8; b=0.4;
            }
            else if (id === 'heart') { const t=u*2*PI; x=16*Math.pow(Math.sin(t),3); y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t); z=(v-0.5)*5; r=1; g=0; b=0.2; }
            else if (id === 'cube') { const s=18; x=(u-0.5)*s; y=(v-0.5)*s; z=(Math.random()-0.5)*s; r=0; g=1; b=0; }
            else if (id === 'butterfly') { const t=u*2*PI; const R = Math.exp(Math.cos(t)) - 2*Math.cos(4*t) - Math.pow(Math.sin(t/12),5); x=R*Math.cos(t)*8; y=R*Math.sin(t)*8; z=(v-0.5)*5; r=1; g=0; b=1; }
            else if (id === 'milkyway') { const ang=u*25+i*0.05; const rad=u*25; x=rad*Math.cos(ang); z=rad*Math.sin(ang); y=(v-0.5)*5; r=0.5; g=0; b=1; }
            else if (id === 'pizza') { const ang=v*2*PI; const rad=u*15; x=rad*Math.cos(ang); z=rad*Math.sin(ang); y=0; if(Math.random()>0.9) y=1; r=1; g=0.6; b=0; }
            else if (id === 'birds') { x=(u-0.5)*40; z=(v-0.5)*20; y=Math.sin(x*0.3+i)*2 + Math.abs(Math.sin(i*0.1))*3; r=1; g=1; b=1; }
            else if (id === 'river') { x=(u-0.5)*50; z=(v-0.5)*20; y=5*Math.sin(x*0.2+i*0.001); r=0; g=0.5; b=1; }
            else if (id === 'dna') { const h=(u-0.5)*40; const a=h*0.5; const off=i%2==0?0:PI; x=8*Math.cos(a+off); z=8*Math.sin(a+off); y=h; r=1; g=0; b=0.5; }
            else if (id === 'cake') { const l=i%3; const rad=l==0?10:l==1?7:4; const h=l==0?-5:l==1?0:5; x=rad*Math.cos(u*2*PI); z=rad*Math.sin(u*2*PI); y=h+(v-0.5)*3; r=1; g=0.4; b=0.6; }
            else if (id === 'blackhole') { const rad=6+u*10; const ang=v*2*PI+rad; x=rad*Math.cos(ang); z=rad*Math.sin(ang); y=(10/rad)*-8; r=0.2; g=0; b=0.4; }
            else if (id === 'sphere') { x=15*Math.cos(u*2*PI)*Math.sin(v*PI); y=15*Math.sin(u*2*PI)*Math.sin(v*PI); z=15*Math.cos(v*PI); r=0; g=0.8; b=1; }
            else if (id === 'donut') { const R=12; const _r=4; x=(R+_r*Math.cos(v*2*PI))*Math.cos(u*2*PI); y=(R+_r*Math.cos(v*2*PI))*Math.sin(u*2*PI); z=_r*Math.sin(v*2*PI); r=1; g=0.5; b=0; }
            else if (id === 'burger') { const l=i%3; const rad=9; const h=l==0?-4:l==1?0:4; x=rad*Math.cos(u*2*PI); z=rad*Math.sin(u*2*PI); y=h+(v-0.5)*3; if(l==1){x*=0.9; z*=0.9;} r=1; g=0.6; b=0.2; }
            else if (id === 'crown') { const ang=u*2*PI; const rad=10; x=rad*Math.cos(ang); z=rad*Math.sin(ang); y=5*Math.abs(Math.sin(ang*2.5))-5; r=1; g=0.8; b=0; }
            else if (id === 'cat') { x=8*Math.cos(u*2*PI)*Math.sin(v*PI); y=8*Math.sin(u*2*PI)*Math.sin(v*PI); z=8*Math.cos(v*PI); if(i>CONFIG.particles*0.8){ x=4+u*3; y=6+v*4; z=0; } if(i>CONFIG.particles*0.9){ x=-4-u*3; y=6+v*4; z=0; } r=0.8; g=0.4; b=1; }
            else if (id === 'color') { x=(Math.random()-0.5)*50; y=(Math.random()-0.5)*50; z=(Math.random()-0.5)*50; r=Math.random(); g=Math.random(); b=Math.random(); }

            target[idx]=x; target[idx+1]=y; target[idx+2]=z;
            baseCol[idx]=r; baseCol[idx+1]=g; baseCol[idx+2]=b;
        }
    }

    let currentSymbol = '';
    function activateSymbol(id) {
        if(currentSymbol === id) return;
        currentSymbol = id;
        
        // Highlight Sidebar
        document.querySelectorAll('.item').forEach(e => e.classList.remove('active'));
        const el = document.getElementById(`item-${id}`);
        if(el) {
            el.classList.add('active');
            el.scrollIntoView({block:'center', behavior:'smooth'});
        }

        // Show Toast
        const s = SYMBOLS.find(x => x.id === id);
        const toast = document.getElementById('toast');
        toast.innerText = s.icon + " " + s.name;
        toast.style.opacity = 1;
        setTimeout(() => toast.style.opacity = 0, 2000);

        setShape(id);
    }

    // --- 5. ROBUST HAND TRACKING ---
    const vid = document.getElementById('webcam');
    const canvas = document.getElementById('output_canvas');
    const ctx = canvas.getContext('2d');
    
    // Stabilizer
    let lastGesture = '';
    let frameCounter = 0;

    function detect(lm) {
        // A. HELPERS (Distance & Logic)
        const d = (i) => Math.hypot(lm[i].x - lm[0].x, lm[i].y - lm[0].y); // Distance from Wrist
        // Is Finger Extended? (Tip is further from wrist than PIP joint)
        const isExt = (tip, pip) => d(tip) > d(pip) * 1.15; 

        // Fingers: Thumb(4), Index(8), Middle(12), Ring(16), Pinky(20)
        // Thumb logic: Check X distance from Pinky Base (17)
        const t = Math.abs(lm[4].x - lm[17].x) > 0.15; 
        const i = isExt(8,6);
        const m = isExt(12,10);
        const r = isExt(16,14);
        const p = isExt(20,18);
        const count = [t,i,m,r,p].filter(Boolean).length;

        // B. DIRECTION (Wrist -> Middle Finger Base)
        const dx = lm[9].x - lm[0].x;
        const dy = lm[9].y - lm[0].y;
        // Atan2 gives angle in Radians. Convert to degrees.
        // 0 is Right, -90 is Up, 90 is Down, 180/-180 is Left
        const angle = Math.atan2(dy, dx) * (180/Math.PI);

        let dir = '';
        // Loose thresholds for ease of use
        if (angle < -45 && angle > -135) dir = 'up';
        else if (angle > 45 && angle < 135) dir = 'down';
        else if (Math.abs(angle) > 135) dir = 'right'; // Mirrored: User points Left -> Camera sees Right
        else dir = 'left'; // Mirrored

        // C. PALM vs BACK
        // If Thumb is "inside" (closer to center line) vs "outside"
        // Heuristic: For a Right hand (on screen Left), Thumb x < Pinky x means Palm.
        const isPalm = lm[4].x < lm[17].x;

        // D. PINCH
        const pinch = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y) < 0.05;

        // --- GESTURE MAPPING ---
        
        // 1. PINCH (Priority)
        if (pinch && m && r && p) return 'blackhole'; 

        // 2. FISTS (0 or 1 finger curled)
        if (count === 0 || (count === 1 && t)) {
            // Check Depth for "Cube" (Punch)
            if (lm[9].z < -0.1) return 'cube'; 
            if (dir === 'up') return 'heart';
            return 'butterfly'; 
        }

        // 3. THUMBS
        if (t && !i && !m && !r && !p) {
            return dir === 'up' ? 'sphere' : 'donut';
        }

        // 4. INDEX FINGER
        if (i && !m && !r && !p) {
            if (dir === 'down') return 'rain';
            if (dir === 'left') return 'sun'; // Pointing Left
            if (dir === 'right') return 'saturn'; // Pointing Right
            // Up Logic
            return isPalm ? 'bigbang' : 'cloud';
        }

        // 5. TWO FINGERS
        if (i && m && !r && !p) return 'cake'; // Peace
        if (t && p && !i && !m && !r) return 'crown'; // Shaka
        if (i && p && !m && !r) return 'color'; // Rock

        // 6. THREE FINGERS
        if (i && m && p && !r) return 'cat';

        // 7. OPEN HAND (4 or 5)
        if (count >= 4) {
            // Spread Check
            const spread = Math.hypot(lm[8].x - lm[20].x, lm[8].y - lm[20].y);
            
            if (dir === 'left' || dir === 'right') {
                return spread > 0.25 ? 'dna' : 'river';
            }
            if (spread > 0.25) return 'pizza';
            
            // Vulcan Split Check (Gap between Middle and Ring)
            const gap = Math.hypot(lm[12].x - lm[16].x, lm[12].y - lm[16].y);
            if (gap > 0.08) return 'burger';

            return isPalm ? 'milkyway' : 'birds';
        }

        return lastGesture; // Fallback
    }

    function onResults(results) {
        // Clear Debug Canvas
        canvas.width = vid.videoWidth;
        canvas.height = vid.videoHeight;
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            
            // Draw Skeleton (Visual Feedback)
            drawConnectors(ctx, lm, HAND_CONNECTIONS, {color: '#00ff00', lineWidth: 2});
            drawLandmarks(ctx, lm, {color: '#ff0000', lineWidth: 1, radius: 3});

            // Detect
            const detected = detect(lm);
            
            // Stabilize (Anti-Flicker)
            if (detected !== lastGesture) {
                frameCounter++;
                if (frameCounter > CONFIG.stabilizationFrames) {
                    lastGesture = detected;
                    frameCounter = 0;
                    document.getElementById('status-bar').innerText = "Status: Detected " + detected.toUpperCase();
                    activateSymbol(detected);
                }
            } else {
                frameCounter = 0;
            }
        } else {
            document.getElementById('status-bar').innerText = "Status: No Hand Detected";
        }
        ctx.restore();
    }

    // --- 6. INIT ---
    const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
    hands.onResults(onResults);
    
    const cam = new Camera(vid, {
        onFrame: async () => await hands.send({image: vid}),
        width: 320, height: 240, facingMode: 'user'
    });
    cam.start();

    // --- 7. ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate);
        const p = particles.geometry.attributes.position.array;
        const c = particles.geometry.attributes.color.array;
        
        for(let i=0; i<CONFIG.particles*3; i++){
            p[i] += (target[i]-p[i]) * 0.08;
            c[i] += (baseCol[i]-c[i]) * 0.05;
        }
        particles.geometry.attributes.position.needsUpdate = true;
        particles.geometry.attributes.color.needsUpdate = true;
        particles.rotation.y += 0.002;
        renderer.render(scene, camera);
    }
    animate();

    // Init
    activateSymbol('milkyway');
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>

